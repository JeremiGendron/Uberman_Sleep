It's almost impossible for me to find a proper watch for data 
collection, since I am too chicken to spend money on them because I have 
no cash.

So I've been spending my morning looking at chips and thinking about how 
to design a wearable smart watch, or which features I would need.

I had a list of important things, but here's an example:
  - MT2523 MCU
  - 4GB SD Module integrated?
  - Vibration simple: wire motor to correct pins, set flag in software
  - Keypad: extent of integration?
  - BTLE needed?
  - Battery
  - HR Monitor I2C or SPI connection
  - LCM Modules integrated?
  - uUSB connector

I would use the chip's flash to load an embedded linux OS into memory 
and go from there. Once linux is loaded it's actually not that hard to 
make it work.

Maybe I should develop the software to justify buying a dev board for 
debugging, and then by the grace of God I'll be able to somehow make a 
PCB layout which works for me?

Dev board brief:
https://s3-ap-southeast-1.amazonaws.com/mediatek-labs-imgs/downloads/e7e3ee52a03f933dbb4fa26c22efb122.pdf?response-content-disposition=inline%3B%20filename%3DLinkIt_2523_HDK_Product_Brief.pdf&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaDmFwLXNvdXRoZWFzdC0xIkgwRgIhAMXz9BgiSTwzWtPKZ9u3dMItgL3Dbrad80GQAGKjQcSjAiEA0qe2%2BPCQHL6oFUrIyEaJz4JLCL4XKlpTMYOcOC5vlaUqxgIIGhABGgw0NDk2OTY5OTIwNjYiDBJebLsJEvDgntjzGSqjAtXaVPHsi3ZExWrBlFeRYP3Tei470LCIGuiliBjSPX4vttlfaG4mjeVn3cx2T8EPQqGGETx6VCtgGemb1Ny2R%2BiySn2raKpThem1STW8sRwkzCefEa1Nqe5WipCnMPIOZHYrPLmKU7pznEuDlmqfn6ZAd12kYIm1aSlmbeviIEx68FR9lgu8SKDWLzKJYIq%2BLO7sYBTHK0Hfw2HejR8n1U9wXBFmejeoV2cKKLUjfaUlwgsve0ymSCogOckBpyEaYZ5Lp7Z%2Fti3KH9MfXqVNt1MlfWKDCphM3PSmz0VZTbRdPVd%2B0HHp8ZrRSKpw6R9eU5ggxl20crc9WZ0FhHZ6M55UP3mSCgRxJ75UamHDx85FVbPISFOZKamCj1R6U6mq%2BC5HIzC628nvBTrHAhWEuhG4J0Ng3eRvzKfVEEJkgEK9Jz9mKbJBPwUtv65vRSGW4%2FE%2FtpBqkZ742sDwmWFmVYyKQWCKmIYVFzpujV%2BtPCQz3TeGIBpxtap1ON4TVhTof7qA9C4h6uqpUDziZFAlkTqwagPI1oIkg8pH0GiwsUULU4e8G8PSilVcJD%2FUrJ7dri48vksYjvExLKslvg6jWlbYNJG17eBF93uztCdwLRB0rR0mVAw%2ByWvhBqqAHTUhsWT185dSG74wV7bq1hnD4%2BsGIiGwLLw94eCCO8ZszhrY8mqhuvpCdZLIRmnDmO4CierGXEbOqLRCu5%2FZOI99TG9a3zwpF1e%2Bt528%2FHdvf26iC2px7YaVicWQLLw4mmR0HA5NAqBVWcrwXG%2Feqmn1wlOKHpjGtPoKnXYs%2FVRGbiQO%2ByIYoeZUj9MeWzLClEHG20vEkg%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAWRNAHRNBCWAJJYK3%2F20191212%2Fap-southeast-1%2Fs3%2Faws4_request&X-Amz-Date=20191212T172419Z&X-Amz-SignedHeaders=host&X-Amz-Expires=600&X-Amz-Signature=6da83a6e92a9046bd9732ffa43ae7c3663496e0b2fc42cd229ce62507810138d

Dev board specific:
https://s3-ap-southeast-1.amazonaws.com/mediatek-labs-imgs/downloads/bb91e7d48d6d242b0ec6b9cc7f321c74.pdf?response-content-disposition=inline%3B%20filename%3DLinkIt_2523_HDK_Users_Guide.pdf&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaDmFwLXNvdXRoZWFzdC0xIkcwRQIgEbhMRhud03KwTwOIlROzV7k0tHGU%2FXryVBpTYbcdrlICIQC4sCtYbcn%2Fi5FVskUcP6zingU05IevqDAa2ZUIGRqWUyrVAggaEAEaDDQ0OTY5Njk5MjA2NiIM%2BJmKP9yNzzHaeX3IKrICPMH0IBpnomRJuHS%2F0ducTXg8UfgiWxwepeOnV%2FPc6J0DMAaETONmD8uUJrBbwu8ZoxspZMHP2886R742p9PF4z1Uj5Mf%2FCohzxf477wBInzUNK1jv36n2v5u85KN%2BjNzV62FjkgAz8uajOg%2FYjf25SVF0JsmvITWhmQXqv7c1sz3aWz%2BOuJwF2%2FCSgxGPz0pB%2BjgxhMkowu5oLtUwZuosuewvJWKs%2Ftn4HEi3VHB647jK%2B%2F3yuYr6%2F3sSq5UkFWnMa8A%2Bd4CDZTmep4KENSxIEU2YtXDrhbC%2FigQlk6xWftccEosm58bLeWWQis7NEXZpolU0LccEvmQdDxWpLDcJBKu749OZ3s2MvRTOU%2FjxfHQgeA3izW7IkabZl2qdBBQKxSaoCXXVgcDMvmRgOSuHMzyMJjbye8FOtQCbCzFJcw0CIrXOIP0MBDB5X01%2FabnIm%2BbH6VwpSw%2FrtIfTrh%2B0kcVtzXikZm8F%2FLlOClZ5ptiN0%2BH%2FeoQhNewF0wq1FEsz7u5b67j75sS5AkgIqCOb2w4bGn9SUJYhmyvMxP0w30eAnLahYVZFpJe8W7v5ttdTRQWFMbQ5m9p01vA9wER4MAUzJEbuQjlw1shYCSOEo%2FzJYGyotjfFrBYufXGkUxpJnQNvINi8jB8GYsa%2BS931C%2BBzdG1hYz8IKRFzmXIdbo2MLEajQMh5SPuVIRa6a5lXmODHR1GcJpTh%2BHPPcfBdqxRO%2BfcP2C6X4ZuKIRdukjUmGiF2njvAXzNcer9F9tlUCOd93%2BalS3bE05vV71F6%2Foi9EsNmie1aV91gclezhs6UBUp0klK7i0iO1oFFsjB3Lw%2BcgkG2zq19iHdDrgIB0Hetmte4xEQUMKJ9nQC7g%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAWRNAHRNBB67MMXXD%2F20191212%2Fap-southeast-1%2Fs3%2Faws4_request&X-Amz-Date=20191212T172016Z&X-Amz-SignedHeaders=host&X-Amz-Expires=600&X-Amz-Signature=fd1f9fb0bc7719bb07f6ab21e56e5c8792bb18563f3ea93aa0d21c05d7dc656b

Chip specific:
https://s3-ap-southeast-1.amazonaws.com/mediatek-labs-imgs/downloads/bb91e7d48d6d242b0ec6b9cc7f321c74.pdf?response-content-disposition=inline%3B%20filename%3DLinkIt_2523_HDK_Users_Guide.pdf&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEMH%2F%2F%2F%2F%2F%2F%2F%2F%2F%2FwEaDmFwLXNvdXRoZWFzdC0xIkcwRQIgEbhMRhud03KwTwOIlROzV7k0tHGU%2FXryVBpTYbcdrlICIQC4sCtYbcn%2Fi5FVskUcP6zingU05IevqDAa2ZUIGRqWUyrVAggaEAEaDDQ0OTY5Njk5MjA2NiIM%2BJmKP9yNzzHaeX3IKrICPMH0IBpnomRJuHS%2F0ducTXg8UfgiWxwepeOnV%2FPc6J0DMAaETONmD8uUJrBbwu8ZoxspZMHP2886R742p9PF4z1Uj5Mf%2FCohzxf477wBInzUNK1jv36n2v5u85KN%2BjNzV62FjkgAz8uajOg%2FYjf25SVF0JsmvITWhmQXqv7c1sz3aWz%2BOuJwF2%2FCSgxGPz0pB%2BjgxhMkowu5oLtUwZuosuewvJWKs%2Ftn4HEi3VHB647jK%2B%2F3yuYr6%2F3sSq5UkFWnMa8A%2Bd4CDZTmep4KENSxIEU2YtXDrhbC%2FigQlk6xWftccEosm58bLeWWQis7NEXZpolU0LccEvmQdDxWpLDcJBKu749OZ3s2MvRTOU%2FjxfHQgeA3izW7IkabZl2qdBBQKxSaoCXXVgcDMvmRgOSuHMzyMJjbye8FOtQCbCzFJcw0CIrXOIP0MBDB5X01%2FabnIm%2BbH6VwpSw%2FrtIfTrh%2B0kcVtzXikZm8F%2FLlOClZ5ptiN0%2BH%2FeoQhNewF0wq1FEsz7u5b67j75sS5AkgIqCOb2w4bGn9SUJYhmyvMxP0w30eAnLahYVZFpJe8W7v5ttdTRQWFMbQ5m9p01vA9wER4MAUzJEbuQjlw1shYCSOEo%2FzJYGyotjfFrBYufXGkUxpJnQNvINi8jB8GYsa%2BS931C%2BBzdG1hYz8IKRFzmXIdbo2MLEajQMh5SPuVIRa6a5lXmODHR1GcJpTh%2BHPPcfBdqxRO%2BfcP2C6X4ZuKIRdukjUmGiF2njvAXzNcer9F9tlUCOd93%2BalS3bE05vV71F6%2Foi9EsNmie1aV91gclezhs6UBUp0klK7i0iO1oFFsjB3Lw%2BcgkG2zq19iHdDrgIB0Hetmte4xEQUMKJ9nQC7g%3D%3D&X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=ASIAWRNAHRNBB67MMXXD%2F20191212%2Fap-southeast-1%2Fs3%2Faws4_request&X-Amz-Date=20191212T172016Z&X-Amz-SignedHeaders=host&X-Amz-Expires=600&X-Amz-Signature=fd1f9fb0bc7719bb07f6ab21e56e5c8792bb18563f3ea93aa0d21c05d7dc656b

Required software will be quite simple:
  - Keypad macro to flag begin sampling
  - Keypad macro to flag awake or trying to sleep
  - Collect sample every 5 seconds when sampling activated
  - Guess time of sleep every 60 seconds when both flags set
  - Keep an average until minute 19 after average sleep guess
  - Vibrate at minute 20 until keypad stops
  - Keypad Macro to input how many seconds it took to fall asleep
  - Modify data on-disk to transform "trying to sleep" into "most likely asleep"
    - Run training on device OR
    - Sync data to phone and train there

It's really not that many steps when u think about it. A lot is taken 
care of by the MCU, like vibration driver, clock, computing, it has a 
bunch of pins... 6 consoles! This is kind of like a state machine.

Let's iron out some functions we will need:
```
sampling = False
trying_sleep = False
set_seconds_to_sleep = None
last_action_key = None

callback = None
buffer = []

def process_keypad(key):
  if key == ENTER:
    if callback is not None:
      callback(buffer)
      buffer = []

    last_action_key = None

  elif last_action_key is None:
    last_action_key = key   

  if set_seconds_to_sleep is not None && last_action_key is 7:
    if callback is None:
      callback = (edit_samples_on_disk(set_seconds_to_sleep, **kwargs))
    buffer += key

  switch(key):
    ...

guesses = []
waiting_guess = 0
when sampling:
  sample = [time.now, get_HR_data(), trying_sleep]
  write_to_disk(filename=session_start_time, sample)
  if waiting_guess is 12:
    guesses += guess_sleep_time(session_start_time)
    if time.now - average(guesses) >= 20 * 60:
      vibrate_until_kill()
      set_seconds_to_sleep = session_start_time
      train_with_difference()
    waiting_guess = 0

  waiting_guess += 5
  wait(5)
```

EDIT: It might be powerful to have the trying to sleep flag be an input 
feature, because it is not the label (the corrected version is the 
label)

The above is pseudocode for a fully operational system. We still need to 
collect data and train a model before we can use the above.

Even if the watch is only accurate to 2-3 minutes, it will be more than 
worth my efforts.

============================================================================

UPDATE for the watch, we are making some progress!

Now, I have an OK idea of the steps I need to take to develop an electronic product:
 1. Find a use case
 2. List out required active components
 3. Create block diagram showing connections
 4. Download EDA/PCB files for parts
 5. Make schematic
 6. Make Gerber from schematic
 7. Test outputs
 8. Order custom PCB
 9. Test PCB, Program, Debug
 10. Design an enclosure
 11. 3D print enclosure
 12. Verify PCB/enclosure dynamic

After that, I don't really need to pay attention because my goal is not mass production.

I want to do designer lifestyle electronics.

In this case, I will KISS for the "watch" (really a wristband with sensors, 2 buttons and ML firmware).

So, that brings us to our current modifications in terms of which parts to use, what is useful and what isn't.

I had to reluctantly let go of the Mediatek MCU platform. Even though it does provide everything out of the box, I couldn't find proper EDA or 
other open-source schematic symbols or footprints when it came to drawing a schematic for that system. I ended up doing some more research and 
it turns out that the manufacturer who makes the heart-rate sensor also makes MCU's with the same ARM Cortex-M4 core as the MT2523.

Most of the components I will be using will come from Maxim Integrated if possible, because they always provide schematic symbols, footprints 
and 3d models which helps a lot for designing.

 - MAX3265{0..2} choice of 3 similar MCU's, varying degree of cache and memory
 - Vibrator motor (https://www.digikey.ca/en/products/detail/seeed-technology-co-ltd/316040001/5487672)
 - 4 switches (https://www.digikey.ca/product-detail/en/grayhill-inc/87FC3-201/GH7750-ND/2680886)
 - Li rechargeable battery (https://www.alibaba.com/product-detail/Rechargeable-3-7v-303040-300mah-lipo_62318443365.html)
 - Micro-usb port (https://www.digikey.com/products/en?keywords=WM17141CT-ND) - dk symbols and footprints
 - Power-management Unit (https://www.digikey.ca/product-detail/en/maxim-integrated/MAX20335AEWX/MAX20335AEWX-ND/9522072)
 - HR sensor chip (https://www.digikey.ca/product-detail/en/maxim-integrated/MAX30102EFD/MAX30102EFD-ND/6166869)
 - SDC mount (https://www.digikey.ca/en/products/detail/3m/2908-05WB-MG/1242497)
 - JTAG 4POS Header ()

==========================================

SO, when taking into account all the physical aspects of making this device, I came to the conclusion that I need to elevate the HR sensor off of the main PCB. This is 
because it needs to be almost directly into contact with my skin to work properly (especially given the integrated solution I'm using which can be seen as lower quality 
than average).

I was really not down to have to mess with flex cable designs, which are very common in the smart watch market for connecting the distant HR sensor. Turns out I can 
probably just use 2 PCBs: a main one and one dedicated to the HR sensor.

The layers of the design I'm imagining are as follows:
 - Top half of the frame, with part of it being a glass or acrylic window peering into a small enclosure
   ====-----=========
       |_ _|
 - The HR sensor is housed into the enclosure and exposes its pins through a female header
 - The main PCB layer which is connected to the HR sensor through its own female header and a M-M set of cables (like SATA but smaller)
 - On the other side of the PCB is where the battery and keypad modules stand
 - Bottom half of the frame, with no window but a small part of the edge taken off to show the keypad module

The main technical challenge here is the glass and how to insert the HR sensor and fasten it properly.

I see all the SW designs employing a protruded enclosure to really give leeway to the sensor to get accurate measurements.

UPDATE: I will make a PCB for the HR sensor that is flush with it and glue its edges to the enclosure. The back (bottom) of the PCB will show a connector. No more 
glass, not useful. Maybe if I run into problems with the sensor getting scratched I'll print a new top part and glue a slim piece of glass over it. Now I have the 
chance to practice a bit of schematic and PCB gerber gen!

Reading data from HR sensor FIFO:
 1. Get FIFO_WR_PTR
  - START;
  - Address device with write mode?? the term "write mode" doesnt appear anywhere else in the fucking document
  - Send address of FIFO_WR_PTR;
  - REPEATED_START;
  - Send device address + "read mode" .. WTF?
  - Read FIFO_WR_PTR;
  - STOP;
 2. The central processor evaluates the number of samples to be read from the FIFO
  - NUM_AVAILABLE_SAMPLES = FIFO_WR_PTR - FIFO_RD_PTR .. An error in the pseudocode.. NICE!
  - NUM_SAMPLES_TO_READ <= NUM_AVAILABLE_SAMPLES
 3. Read NUM_SAMPLES_TO_READ samples from the FIFO
  - START;
  - Send device address + write mode (I2C spec)
  - Send address of FIFO_DATA;
  - REPEATED_START;
  - Send device address + read mode
  - for (i = 0; i < NUM_SAMPLES_TO_READ; i++) {
      Read FIFO_DATA;
      Sead LED1[23:16];
      READ FIFO_DATA;
      Read FIFO_DATA;
      Save LED1[15:8];
      Read FIFO_DATA;
      Save LED1[7:0];
      Read FIFO_DATA;
      Save LED2[23:16];
      Read FIFO_DATA;
      Save LED2[15:8];
      Read FIFO_DATA;
      Save LED2[7:0];
      Read FIFO_DATA;
    }
  - STOP;
  - START;
  - Send device address + write mode
  - Send address of FIFO_RD_PTR
  - Write FIFO_RD_PTR;
  - STOP;

This is the most confusing piece of code every lol. Turns out that when selecting a slave as the I2C master, you can use the 8th bit to signal whether you are reading 
from or writing to the slave. In our case the address is 7 bits and the last bit is either 0 for write or 1 for read. The addressing scheme follows a start condition, 
which is when SDA gets pulled to low (normally high state) and SCL is high. When SDA transitions to high from low on a high SCL, the stop condition is issued. After 
receiving its slave id, the sensor issues an ACK by pulling SDA low for one clock cycle (standard I2C procedure). When in write mode, during the 9th clock pulse, the 
sensor pulls down SDA to signal successful reception of the data.
"The master pulls down SDA
during the 9th clock cycle to acknowledge receipt of data
when the MAX30102 is in read mode. An acknowledge
is sent by the master after each read byte to allow data
transfer to continue. A not-acknowledge is sent when the
master reads the final byte of data from the MAX30102,
followed by a STOP condition." basically master pulls SDA high again == NACK

Generally, I feel like I learned a lot by reading the datasheet for one of the central parts of this design. I understand the concept of pull-up resistors now as well. 
This will help me make decisions when drawing the PCBs on the schematic. For example, I now know that I can plug VLED+ to both terminals on the chip and through 
firmware loaded onto my microcontroller decide which LED gets to draw current at all. The block diagrams were confusing, they seemed to suggest that only 1 VLED port 
was used, but the schematic or footprints indicated 2 ports.

Tomorrow I will read the datasheet for the MCU and attempt to wire up both together to see where it leads me (what mistakes I make, what I don't understand).

It would be really nice to get to understand more precisely what the whole system will behave like, and then writing software for it will be super interesting.


======================================

UPDATE: We are back with the single PCB design. For a number of reasons, a multi-pcb layout didn't sound fun to design and implement.

I have more carefully chosen the pieces in this revision: 
 - MAX32650 96 WLP Low-power MCU w/ FPU 32bit 3M FLASH 1M RAM (https://www.maximintegrated.com/en/products/microcontrollers/MAX32650.html)
 - Vibrator motor (https://www.digikey.ca/en/products/detail/seeed-technology-co-ltd/316040001/5487672)
# I want a symbol, footprint and 3D model for this damn piece - 4 switches (https://www.digikey.ca/product-detail/en/grayhill-inc/87FC3-201/GH7750-ND/2680886)
 - Li rechargeable battery (https://www.alibaba.com/product-detail/Rechargeable-3-7v-303040-300mah-lipo_62318443365.html)
 - Micro-usb port (https://www.digikey.com/products/en?keywords=WM17141CT-ND) - dk symbols and footprints
 - Power-management Unit (https://www.digikey.ca/product-detail/en/maxim-integrated/MAX20335AEWX/MAX20335AEWX-ND/9522072)
 - HR sensor chip (https://www.digikey.ca/product-detail/en/maxim-integrated/MAX30102EFD/MAX30102EFD-ND/6166869)
 - SDC mount (https://www.digikey.ca/en/products/detail/3m/2908-05WB-MG/1242497)
 - Various pin headers for debugging

I decided to go with the -35 variant of the PMIC/PMU because it has less stuff to deal with than the -45 version. Same goes for the -0 version of the MCU instead of the 
originally envisioned -2 version which has 48 more pins. I don't have a lot of IO requirements for the device, only I2C with the sensor, PMU control, USB data, SDHC and 
SWD/JTAG.

I have also learned how to do hierarcical sheets in KiCAD, which makes my shit much neater. Implemented my first pull-up resistor in-schematic (I think). FULLY wired 
the HR sensor with its appropriate power inputs (1.8V main w/ 3.3V LED power) and data pins (INT*, SDA, SCL -- thought not sure if INT* is output or bi).

Saving progress for now.

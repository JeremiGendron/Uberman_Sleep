This will be the notepad for this project.

Basically, I need a solution for sleeping X amount of minutes, as 
precisely as possible.

I think I can create a neural net which can infer time of falling asleep 
based on only heart rate data.

I believe the industry standard is really bad (relies on people waring 
smartwatch while going to bed, mainly focuses on whether the watch is 
moving, adding a few minutes because people dont sleep as soon as they 
stop moving, more likely to log sleep if at night, etc.) This is the 
reason why there doesn't exist this application already. People arent 
able to infer when u fall asleep.

So, maybe I should use a combination of heart rate and accelerometer; 
but that data I can't practice on. I would need to get a device and log 
my sleep with a custom app. Unfortunately I'm uncomfortable with 
purchasing gadgets for projects, because in the past I have never 
completed a project for which I needed to purchase some hardware. 
Granted, I do still plan to use some of the hardware I've purchased for 
practice in other domains.

It's really a bummer to not get it on the first try and not know what 
the reason is. So I'm super depressed right now because I really want to 
make this application happen. I think the potential is huge, for 
undisclosed reasons.

JESUS im sad.

Ok, here's what I at the very least have:
 - Real life heart rate data
 - Some knowledge on working with bigger datasets

Maybe the secret to succeeding is manually reducing my heart rate when I 
fall asleep so I can have a hard floor for when "asleep" is counted... 
lol

Based on my limited sleep knowledge, I would guess that heart rate 
variability is the key feature to look at.

Perhaps I can even solve this issue with a linear regression. But that 
would mean that I should cool off in relatively the same time for 
accurate measures. That's not really an option, but I'm not sure how you 
can even get a better resolution.

Now that I think about it, maybe a 2D Conv might do the trick. Here me out.
I can have different sections of the 2D plane be for different time scales.

Ok that's pretty much all I got... haaa ha

Perhaps the best thing I can do is read research papers, try to 
implement the networks which people have tested on similar or the same 
data and develop a better intuition for this problem over time.

Wish me luck.


===============

Alrighty. Developing System Code for a MCU you have never owned a board for is not the easiest.

The best solution I've found goes as follows:
 - Develop application code and test on host machine
 - Load hello_world sample on Eclipse MCU with STM32F4DISCOVERY board emulation
 - Remove hello_world code and insert application code
 - Run simulations, debug
 - Evaluate resource necessities of application code
 - Get STM34F4DISCOVERY board
 - Run and debug basic application code on eval board
 - Order peripherals from digikey (vibmot, piezo, sensors)
 - Practice tickling the eval board's jimmies to get a feel for 'em
 - Receive the board and begin developing peripheral code
 - Notice that it's really hard to manage interrupts at that scale
 - Contemplate learning ins and outs of FreeRTOS
 - Write more peripheral code and begin succeeding at data flow
 - Make sure you've been wearing your aliexpress smartwatch for data
 - Go back in the past and write an Android app to save watch's data
 - Refine machine learning model with Android data
 - Change application code, upgrade peripheral code
 - Test data collection and execution of the watch's data to test memory
 - Develop exotic features of the product
 - Refine the schematic
 - Simulate and fail multiple times cause you suck at electrical engineering
 - Eventually think you're on the right path
 - PCB conversion takes a lot of time, mainly because you're scared
 - Eventually get the guts to order a custom PCB prototype, likely from China
 - You actually have to sodder your components in place
 - Verify that everything works with the prototype, just like eval board
 - Probably won't, so keep debugging and ordering more
 - Meanwhile you've been designing and enclosure for the product
 - Develop a mechanical engineering testing pipeline
 - Use the pipeline to test whether the enclosure does the job
 - Refine the enclosure, add detail, artwork, customizations
 - Put the best version of PCB prototype into the enclosure
 - Test in real life
 - Fail and debug a few more times
 - Succeed
